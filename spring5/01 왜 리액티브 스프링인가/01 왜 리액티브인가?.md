# 왜 리액티브인가?  
  
서비스 애플리케이션에서 가장 중요하게 생각할 문제는 **어떻게 대응할 것인가?** 이다.       
쉽게 말하자면, 서비스 애플리케이션은 부하의 변화 및 외부 서비스의 가용성 변화에 대응을 해야한다.         
즉, **사용자 요청에 대한 응답 능력에 영향을 미칠 수 있는 모든 변화에 대응해야한다.(Reactive)**    
    
**변화에 대응하자는 일차적인 목표를 달성하는데는 몇 가지 방법이 있다.**        

1. 탄력성    
2. 복원력 

## 탄력성  
  
**탄력성이란?**    
* 다양한 작업 부하에서 응답성을 유지하는 능력을 의미한다.     
* 즉, 사용자 요청에 대한 응답 능력에 영향을 미칠 수 있는 모든 변화에 대응해야한다.   
         
작업이 많아지면 시스템 처리량이 자동으로 증가해야하고 작업이 감소하면 자동으로 감소해야한다.             
탄력성이 없는 시스템은 수요가 증가하면 평균 지연 시간이 증가하고, 시스템의 응답성에 직접적인 영향을 미친다.       
탄력성이 있는 시스템은 **평균 지연 시간에 영향을 미치지 않고 시스템을 확장할 수 있기에 시스템 응답성을 유지할 수 있다.**       
   
```     
지연 시간은 Reactive의 필수적인 특성이다   
탄력성이 없는 시스템에서는 수요가 증가하면 평균 지연 시간이 증가하고, 이것이 시스템의 응답성(Reactive)에 직접적인 영향을 미친다.  
```

`스케일 업`, `스케일 아웃`을 통해 시스템의 처리량을 증가시킬 수 있고 그 결과로 응답 능력을 향상시킬 수 있다.      
하지만, 역으로 시스템의 작업량이 낮은 경우에는 시스템을 축소하는 방향으로 비즈니스 비용을 절감하기도 해야한다.       
이렇듯 수평적 또는 수직적 확장(증대/감소)을 통해 우리가 목표하는 탄력성을 달성하고 유지할 수 있다.         
 
그러나 일반적으로 분산 시스템의 확장성을 달성하기 위해    
시스템 병목 지점 또는 동기화 지점을 확장하는 정도로 그치는게 일반적이다.    
 
이러한 문제는 암달의 법칙과 건터의 보편적 확장성 모델로 설명할 수 있으며   
이후, 배우게 될 웹플럭스-비동기 논블로킹에서 이문제를 다루고 해결하는 법에 대해서 공부할 것이다.    

      
## 복원력 

장애 발생과 상관없이 응답성(Reactive)에 대한 유지력을 갖추지 않은 채, 확장 가능한 분산시스템을 구축하는 것은 어려운 일이다.     
고품질 사용자 경험을 제공하기 위해서는 시스템의 응답성에 관심을 기울여야 한다.           
시스템에 대한 허용 기준은 시스템 실패에도 반응성을 유지할 수 있는 능력, 즉 시스템 복원력을 유지하는 것이다.      
**복원력은 시스템의 기능 요소를 격리해 모든 내부 장애를 격리하고 독립성을 확보함으로써 달성할 수 있다.(장애 전파X)**       
     
예시로, 결제 서비스가 중단되더라도 사용자 주문을 접수하고 이후에 자동으로 재시도함으로써 사용자를 원치 않는 장애로부터 보호할 수 있다.     
다른 예시로, 댓글 서비스에 장애가 발생하더라도 장바구니 확인이나 결제 서비스는 아무런 영향없이 정상적으로 동작해야한다.   

## 탄력성과 복원력 그리고 확장성 
 
탄력성과 복원력은 서로 밀접하게 결합되어있다.       
이 2가지를 모두 만족할 때, 시스템은 진정한 응답성(Reactive)를 가질 수 있다.       
그리고 이 2가지를 만족한 애플리케이션은 추가적으로 확장성을 도입해볼 수도 있다.     
   
확장성을 통해 다수의 복제본을 가지는 애플리케이션으로 구성할 수 있고     
이를 통해, 장애가 발생하더라도 시스템의 나머지 부분에 미치는 영향을 최소화하면서 복제본으로 전환할 수 있다.   

# 메시지 기반 통신 

* 컴포넌트를 연결하는 방법
* 낮은 결합도, 시스템 결합 및 확장성 유지 

분산 시스템에서 위와 같은 작업들을 동시에 달성할 수 있는지는 불분명하다.        
이를 증명하기 위해 HTTP를 이용해 컴포넌트 간의 통신을 수행하는 상황을 검토해보겠다.    

## 예시 

```java
@RequestMapping("/resource")  
public Object processRequest() {
    RestTemplate template = new RestTemplate();
    
    ExamplesCollection result = template.getForObject(
        "http://example.com/api/resource2",
        ExamplesCollection.class
    );
    ...
    processResultFurther(result);
}
```

사용자의 요청으로 호출되는 리퀘스트 핸들러를 정의해보았다.     
핸들러는 호출이 일어날 때마다 외부 서비스에 대한 추가 HTTP 요청을 발생시키고 차례로 다음 단계를 실행시킨다.   
이 코드는 논리적으로 투명해보이지만 몇 가지 문제가 있다.   

[#](#)  

타임라인에서 알 수 있듯이, 리퀘스트를 보내고 응답이 올때 까지 블록킹 대기상태가 되는 것을 알 수 있다.   
즉, 처리 시간의 일부만 효과적인 CPU 사용을 위해 할당되고 나머지는 스레드 A는 I/O에 의해 차단되며 다른 요청을 처리할 수 없다.        
            
이러한 문제를 해결하기 위한 방법 중 하나로    
자바에는 '스레드 풀'을 이용해 추가 스레드를 할당하여 병렬처리를 할 수 있다.         
하지만, 부하가 높은 상태에서는 이러한 기법 또한 새로운 I/O 작업을 동시에 처리하는데에는 매우 비효율적이다.    
(스레드를 많이 만들면 그만큼 동시성 문제를 해결하고 그 과정에서의 지연 시간도 길어질 수 있다.)    
이 같은 문제는 웹플럭스-비동기 논블로킹 통신에서 다시 한번 다루어보자   
      
**그렇다면 어떻게 해결할 수 있을까🤔**     
간단하게도, 비동기 논 블로킹 모델을 사용해에서 I/O 측면에서 리소스 활용도를 높이는 방법이 있다.      
현실에서 메시지를 보내고 할일 하다가 다시 메시지를 받고 보내는 방식이 업무 최적화에 남은 시간을 효율적으로 활용할 수 있게 해준다.       

[#](#) 

일반적으로 **`분산 시스템`에서 서비스 간에 통신을 할 때 자원을 효율적으로 사용하기 위해서는 `메시지 기반 통신 원칙`을 따랴야 한다.**           
즉, 비동기 논블로킹 방식으로 메시지를 보낼 수 있어야하며 또한 이러한 접근 방식은 **위치 투명성을 활성화해 시스템 확장성을 향상시킨다.**    
메시지 기반 통신을 수행하는 방법 중 하나는 **메시지 브로커**를 이용하는 것이다.          
  
**메시지 브로커의 장점**     
* 메시지 대기열(큐)을 모니터링해서 시스템이 부하를 관리할 수 있고 장애 대응을 할 수도 있다.     
* 명확한 흐름제어를 제공하고 전체 설계를 단순화싴니다.    

[#](#) 

지금까지 기술한 내용을 종합하면 위와 같은 리액티브 시스템의 기본 원리를 알 수 있다.    
      
그림에서 알 수 있듯이, **분산 시스템으로 구현되는 모든 비즈니스의 핵심 가치는 응답성이다.**              
시스템이 높은 응답성을 확보했다는 것은 **탄력성 및 복원력 같은 기본 기법도 이미 뒤따른다는 의미이다.**            
그리고 **응답성, 탄력성 및 복원력을 모두 확보하는 방법 중 하나로 메시지 기반 통신이 있다.**      
이러한 원칙을 제대로 구축한 시스템은 모든 구성요소가 독립적이고 적절하게 격리돼 있기 때문에 유지 보수 및 확장이 용이하다.       
(이 같은 개념은 리액티브 선언문(리액티브 시스템의 개념을 설명하는 용어집)에 정의되어있다.)      
    
**리액티브 선언문**   
리액티브 선언문은 기업과 개발들이 기존 개념을 동일하게 이해하도록 만들어진 선언문이다.      
리액티브 시스템과 리액티브 선언문은 아키텍처와 관련이 있으며,        
이는 대규모 분산 애플리케이션은 물론이고 소규모 단일 노드 애플리케이션에서도 적용할 수 있다.    

# 반응성에 대한 유스케이스 

리액티브 시스템은 아키텍처에 관한 것이며, 어디에나 적용될 수 있다.     
이번 단락에서는 리액티브 시스템을 만드는 데 도움이 되는 설계 개선 및 변경점에 대해서 알아본다.   

## 소형 웹 스토어(마이크로 서비스 아키텍처)

[#](#)  

위 아키텍처는 리액티브 시스템을 활용할 수 있는 유용한 사례중 하나이다.(모던 마이크로서비스 패턴 적용)      
위치 투명성을 달성하기 위해 [API 게이트웨이 패턴](https://docs.microsoft.com/ko-kr/dotnet/architecture/microservices/architect-microservice-container-applications/direct-client-to-microservice-communication-versus-the-api-gateway-pattern)을 사용했다.  
   
노드간의 강결합이 이루어지지 않았으므로, 서비스 노드를 스케일 아웃하여 가용성을 높일 수 있고     
요청을 처리하는 서비스에 대한 지식이 없어도 해당 리소스를 식별할 수 있게 해준다.       
  
```  
단, 클라이언트가 최소한 자원 이름은 알아야한다.     
API 게이트웨이가 요청 URI의 일부로 서비스 이름을 제공받으면 레지스트리 서비스에 요청해 특정 서비스 주소를 확인하기 때문이다.   
```
  
또한, 각 서비스의 가용성 정보를 최신으로 유지하는 책임은(어느 서비스를 사용할 것인지)     
'서비스 레지스트리 패턴'으로 구현하고 클라이언트 측 '디스커버리 패턴'을 통해 달성한다.     
위 그림에서는 서비스 게이트웨이와 서비스 레지스트리가 동일한 시스템에 설치되어 있기 때문에 소규모 시스템의 경우 유용할 수 있다.  
    
**장애 복원력**    
아파치 카프카를 이용해 '적절하게 구성한 메시지 기반 통신'과 '독립적인 결제 서비스'에 의해 이루어진다.(재시도 가능)       
데이터베이스는 Replication 을 통해 하나가 중단되더라도 복원할 수 있는 복원력을 유지했다.       
   
**응답성**          
주문 요청을 받자마자 우선 응답을 보낸후, 이를 비동기적으로 처리해 사용자 결제 요청을 결제 서비스로 보낸다.       
최종 결과 안내는 지원하는 채널(이메일)에 의해 나중에 전달된다.      

## 애널리틱스 분야(스트리밍 아키텍처)  
  
리액티브 시스템 접근법이 적절한 또 다른 복잡한 영역 중 하나로 애널리틱스 분야가 있다.        
애널리틱스는 엄청난 양의 데이터를 다루면서 런타임에 처리하고     
사용자에게 실시간으로 통계를 제공함으로써 항상 최신의 정보를 유지하는 기능을 제공한다.    

엄청난 데이터를 처리하고 통신 네트워크 상태, 품질 및 트래픽에 대한 실시간 모니터링을 제공하는 것은 어렵다.  
이 시스템을 설계하기 위해 **스트리밍**이라는 효율적인 아키텍처를 사용할 수 있다.   

[#](#)  

스트리밍 아키텍처는 데이터 처리 및 변환 흐름을 만드는 것이다.         
일반적으로 이러한 시스템은 짧은 지연 시간과 높은 처리량이 특징이다.      
따라서 **통신 네트워크 상태에 대한 분석된 업데이트에 응답하거나 전달하는 능력이 매우 중요하다.**     

이러한 가용성이 높은 시스템을 구축하려면 리액티브 선언문에서 언급한 기본 원칙에 의존해야한다.    
복원성을 확보하기 위해 배압 지원(장애 전파 방지)을 활성화해야한다.     

메시지 브로커를 통한 메시지 기반 통신을 사용해 작업 부하 관리를 효울적으로 수행할 수 있다.       
이 통신 방식은 메시지를 내부 저장소에 보관하고 요청이 있을 때 전송할 수 있다.    

또한 시스템의 각 구성 요소를 적절하게 변경해 시스템 처리량을 탄력적으로 확장하거나 줄일 수 있다.   
      
실제 환경에서는 데이터 스트림이 일괄 처리로 데이터베이스에 저장되거나         
윈도우잉(windowing) 또는 머신러닝을 적용해 거의 실시간에 가깝게 처리될 수도 있다.         
하지만, 리액티브 선언문이 제공하는 모든 기본 원칙은 전체 도메인 또는 비즈니스 아이디어와 관계없이 유효하다.      
     
리액티브 시스템 구축의 기본 원리를 적용한 영역은 다양하게 존재한다.(여러 아키텍처들)     
사용자에게 효과적이고 인터랙티브한 피드백을 제공하는 거의 모든 종류의 분산 시스템 구축에 리액티브 원리를 적용할 수 있기 때문에,  
리액티브 시스템의 적용 영역은 예시로 제공한 영역으로 제한되지는 않는다.     
  
# 왜 리액티브 스프링인가?     
> 스프링 프레임워크를 리액티브로 전환하는 이유   

리액티브 접근법을 통해, 탄략성과 복원력과 같은 기본 요소의 사용을 확대하고     
리액티브 시스템을 위해 일반적으로 사용되는 마이크로서비스의 예를 살펴보았다.   
 
리액티브 시스템의 복잡성을 강조하는 것은 중요하며 이를 위해 아키텍처 관점에서 살펴보았다.  
그리고 이러한 시스템을 구축하는 것은 매우 어려운 것 또한 알게 되었다.       

리액티브 시스템을 쉽게 구축하려면 먼저 여러 프레임워크를 분석한 다음 그 중 하나를 선택하면 된다.    
프레임워크를 선택하는 가장 일반적인 방법의 하나는 각 프레임워크의 기능, 연관성 및 커뮤니티를 분석하는 것이다.    
JVM 세계에서 리액티브 시스템을 구축하는데 가장 널리 알려진 프레임워크는 Akka, Vert.x 이다.  
(Akka 와 Vert.x 에대한 설명은 생략하겠다.)   

스프링 프레임워크는 개발자에게 친숙한 프로그래밍 모델을 사용해 웹 애플리케이션을 구축할 수 있는 다양한 방법을 제공한다.  
하지만 견고한 리액티브 시스템을 구축하는데 몇가지 제약이 있어서 제대로 도입하지 못하고 있었다.(지금은 제공한다.)  

## 서비스 레벨에서의 반응성 

스프링 진영에서, 리액티브 시스템에 대한 수요 증가로 **스프링 클라우드**라는 새로운 스프링 프로젝트가 개발되었다.   
스프링 클라우드 프레임워크는 분산 시스템 구축을 단순화하는 프로젝트이다.       
결과적으로 스프링 프레임워크 생태계는 리액티브 시스템을 구축하는데 적합하게 변했다.     
(최소한의 노력으로 견고한 리액티브 마이크로서비스 시스템을 구축하는 솔루션이 등장한 것이다.)   

```  
큰 시스템은 더 작은 규모의 시스템으로 구성되기 때문에 구성 요소의 리액티브 특성에 의존한다.     
즉, 리액티브 시스템은 설계 원칙을 적용하고, 이 특성을 모든 규모에 적용해 그 구성 요소를 합성할 수 있게 하는 것을 의미한다.  
``` 
  
리액트 선언문에서 주지하다시피, 전체 시스템 설계는 리액티브 시스템을 구축하는 데 있어 하나의 요소일 뿐이다.      
따라서 구성 요소 수준에서도 리액티브 설계 및 구현을 제공하는 것이 중요하다.    
이러한 맥락에서, **설계 원칙이란 컴포넌트 사이의 관계를 말한다.(기본 요소를 조합하는 데 사용하는 프로그래밍 기법)**       
자바에서 코드를 작성하는 가장 보편적인 기법은 **명령형 프로그래밍**이다.     

[#](#) 

이 그림에는 웹 스토어 애플리케이션을 구성하는 2개의 컴포넌트가 있다.      
이 경우 OrdersService는 사용자 요청을 처리하기 위해 ShoppingCardServie를 호출한다.        
    
내부에 있는 ShoppingCardService 가 HTTP 요청이나 데이터베이스 쿼리와 같이 시간이 걸리는 I/O 작업을 실행한다고 가정한다.    
명령형 프로그래밍의 단점을 이해하기 위해 앞서 언급한 컴포넌트 간의 상호 작용에 대한 가장 일반적인 구현 예시를 보자   

```java
interface ShoppingCardService {
    Output calculate(Input value);
}

class OrderService {
    private final ShoppingCardService scService;
    
    void process() {
        Input input = ...
        Output output = scService.calculate(input);
        ...
    }
}
```

이 서비스는 시간과 강결합되거나 단순히 OrderServie를 실행하는 경우에도 ShoppingCardService의 실행 결과와 강결합된다.       
**안타깝게도 이러한 기술을 사용하면 ShoppingCardService 가 요청을 처리하는 동안 다른 직업을 실행할 수 없다.**           
  
`scService.calculate(input);`를 처리하는 동안 스레드가 차단된다.            
따라서 OrderService에서 별도의 독립적인 처리를 실행하려면 추가 스레드를 할당해야한다.      
하지만, 추가 스레드를 할당하는 것은 낭비일 수 있다.     
결과적으로 리액티브 시스템의 관점으로 본다면 그런 식의 동작은 허용하지 않는다.     

```java
interface ShoppingCardService {
    void calculate(Input value, Consumber<Output> c);
}

class OrderService {
    private final ShoppingCardService scService;
    
    void process() {
        Input input = ...;
        scService.calculate(input, output -> { ... });    
    }
}
```
  
ShoppingCardService 인터페이스 선언입니다.           
calculate 메서드는 두 개의 인자를 받고 void 를 반환한다.      
          
이는 설계 관점에서 호출하는 인스턴스가 즉시 대기 상태에서 해제될 수 있으며,           
그 결과는 나중에 `Consumer<>` 콜백으로 전달된다는 뜻이다.               
    
OrderService 선언이다.       
여기서는 비동기식으로 ShopCardService 를 호출하고, 이후 작업을 진행한다.        
ShopCardService가 콜백 함수를 실행하면 실제 결과에 대한 처리를 계속할 수 있다.    
 
이제 OrderService는 작업 완료 후에 반응할 콜백 함수를 전달한다.         
이것은 OrderService 가 ShoppingCardService 로 부터 분리 됐음을 의미한다.         
아울러 OrderService 로 결과를 전달하는 함수형 콜백 호출을 위해 동기 또는     
비동기적인 방식으로 ShoppingCardService#calculate 메서드를 구현할 수 있다.    

```java
class SyncShoppingCardService implements ShoppingCardService {
    public void calculate(Input value, Consumer<Output> c) {
        Output result = new Output();
        c.accept(result);
    }
}

class AsyncShoppingCardService implements ShoppingCardService {
    public void calculate(Input value, Consumer<Output> c) {
        new Thread(() -> {
            Output result = template.getForObject(...);
            ...
            c.accept(result);
        }).start();
    }
}
```

