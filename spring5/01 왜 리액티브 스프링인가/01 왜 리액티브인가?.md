# 왜 리액티브인가?  
  
서비스 애플리케이션에서 가장 중요하게 생각할 문제는 **어떻게 대응할 것인가?** 이다.       
쉽게 말하자면, 서비스 애플리케이션은 부하의 변화 및 외부 서비스의 가용성 변화에 대응을 해야한다.         
즉, **사용자 요청에 대한 응답 능력에 영향을 미칠 수 있는 모든 변화에 대응해야한다.(Reactive)**    
    
**변화에 대응하자는 일차적인 목표를 달성하는데는 몇 가지 방법이 있다.**        

1. 탄력성    
2. 복원력 


## 탄력성  
  
**탄력성이란?**    
* 다양한 작업 부하에서 응답성을 유지하는 능력을 의미한다.     
* 즉, 사용자 요청에 대한 응답 능력에 영향을 미칠 수 있는 모든 변화에 대응해야한다.   
         
작업이 많아지면 시스템 처리량이 자동으로 증가해야하고 작업이 감소하면 자동으로 감소해야한다.             
탄력성이 없는 시스템은 수요가 증가하면 평균 지연 시간이 증가하고, 시스템의 응답성에 직접적인 영향을 미친다.       
탄력성이 있는 시스템은 **평균 지연 시간에 영향을 미치지 않고 시스템을 확장할 수 있기에 시스템 응답성을 유지할 수 있다.**       
   
```     
지연 시간은 Reactive의 필수적인 특성이다   
탄력성이 없는 시스템에서는 수요가 증가하면 평균 지연 시간이 증가하고, 이것이 시스템의 응답성(Reactive)에 직접적인 영향을 미친다.  
```

`스케일 업`, `스케일 아웃`을 통해 시스템의 처리량을 증가시킬 수 있고 그 결과로 응답 능력을 향상시킬 수 있다.      
하지만, 역으로 시스템의 작업량이 낮은 경우에는 시스템을 축소하는 방향으로 비즈니스 비용을 절감하기도 해야한다.       
이렇듯 수평적 또는 수직적 확장(증대/감소)을 통해 우리가 목표하는 탄력성을 달성하고 유지할 수 있다.         
 
그러나 일반적으로 분산 시스템의 확장성을 달성하기 위해    
시스템 병목 지점 또는 동기화 지점을 확장하는 정도로 그치는게 일반적이다.    
 
이러한 문제는 암달의 법칙과 건터의 보편적 확장성 모델로 설명할 수 있으며   
이후, 배우게 될 웹플럭스-비동기 논블로킹에서 이문제를 다루고 해결하는 법에 대해서 공부할 것이다.    

      
## 복원력 

장애 발생과 상관없이 응답성(Reactive)에 대한 유지력을 갖추지 않은 채, 확장 가능한 분산시스템을 구축하는 것은 어려운 일이다.     
고품질 사용자 경험을 제공하기 위해서는 시스템의 응답성에 관심을 기울여야 한다.           
시스템에 대한 허용 기준은 시스템 실패에도 반응성을 유지할 수 있는 능력, 즉 시스템 복원력을 유지하는 것이다.      
**복원력은 시스템의 기능 요소를 격리해 모든 내부 장애를 격리하고 독립성을 확보함으로써 달성할 수 있다.(장애 전파X)**       
     
예시로, 결제 서비스가 중단되더라도 사용자 주문을 접수하고 이후에 자동으로 재시도함으로써 사용자를 원치 않는 장애로부터 보호할 수 있다.     
다른 예시로, 댓글 서비스에 장애가 발생하더라도 장바구니 확인이나 결제 서비스는 아무런 영향없이 정상적으로 동작해야한다.   

## 탄력성과 복원력 그리고 확장성 
 
탄력성과 복원력은 서로 밀접하게 결합되어있다.       
이 2가지를 모두 만족할 때, 시스템은 진정한 응답성(Reactive)를 가질 수 있다.       
그리고 이 2가지를 만족한 애플리케이션은 추가적으로 확장성을 도입해볼 수도 있다.     
   
확장성을 통해 다수의 복제본을 가지는 애플리케이션으로 구성할 수 있고     
이를 통해, 장애가 발생하더라도 시스템의 나머지 부분에 미치는 영향을 최소화하면서 복제본으로 전환할 수 있다.   

# 메시지 기반 통신 

* 컴포넌트를 연결하는 방법
* 낮은 결합도, 시스템 결합 및 확장성 유지 

분산 시스템에서 위와 같은 작업들을 동시에 달성할 수 있는지는 불분명하다.        
이를 증명하기 위해 HTTP를 이용해 컴포넌트 간의 통신을 수행하는 상황을 검토해보겠다.    

## 예시 

```java
@RequestMapping("/resource")  
public Object processRequest() {
    RestTemplate template = new RestTemplate();
    
    ExamplesCollection result = template.getForObject(
        "http://example.com/api/resource2",
        ExamplesCollection.class
    );
    ...
    processResultFurther(result);
}
```

사용자의 요청으로 호출되는 리퀘스트 핸들러를 정의해보았다.     
핸들러는 호출이 일어날 때마다 외부 서비스에 대한 추가 HTTP 요청을 발생시키고 차례로 다음 단계를 실행시킨다.   
이 코드는 논리적으로 투명해보이지만 몇가지 문제가 있다.   

[#](#)  

타임라인을 보면 알 수 있듯이, 리퀘스트를 보내고 응답이 올때 까지 블록킹 대기상태가 되는 것을 알 수 있다.   
즉, 처리 시간의 일부만 효과적인 CPU 사용을 위해 할당되고 나머지는 스레드 A는 I/O에 의해 차단되며 다른 요청을 처리할 수 없다.        
        
**이러한 문제를 어떻게 해결할 수 있을까?🤔**            
자바에는 '스레드 풀'을 이용해 추가 스레드를 할당하여 병렬처리를 할 수 있다.       
하지만, 부하가 높은 상태에서는 이러한 기법 또한 새로운 I/O 작업을 동시에 처리하는데에는 매우 비효율적이다.    
(스레드를 많이 만들면 그만큼 동시성 문제를 해결하고 그 과정에서의 지연 시간도 길어질 수 있다.)    
이 같은 문제는 웹플럭스-비동기 논블로킹 통신에서 다시 한번 다루어보자   
      
**그렇다면 어떻게 해결할 수 있을까🤔**     
간단하게도, 비동기 논 블로킹 모델을 사용해에서 I/O 측면에서 리소스 활용도를 높이는 방법이 있다.      
현실에서 메시지를 보내고 할일 하다가 다시 메시지를 받고 보내는 방식이 업무 최적화에 남은 시간을 효율적으로 활용할 수 있게 해준다.       

[#](#) 

일반적으로 분산 시스템에서 서비스 간에 통신할 때 자원을 효율적으로 사용하기 위해서는 메시지 기반 통신 원칙을 따랴야 한다.    
즉, 비동기 논블로킹 방식으로 메시지를 보낼 수 있어야하며 또한 이러한 접근 방식은 위치 투명성을 활성화해 시스템 확장성을 향상시킨다.   





