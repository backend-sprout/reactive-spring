# 왜 리액티브인가?  
  
서비스 애플리케이션에서 가장 중요하게 생각할 문제는 **어떻게 대응할 것인가?** 이다.       
쉽게 말하자면, 서비스 애플리케이션은 부하의 변화 및 외부 서비스의 가용성 변화에 대응을 해야한다.         
즉, **사용자 요청에 대한 응답 능력에 영향을 미칠 수 있는 모든 변화에 대응해야한다.(Reactive)**    
    
**변화에 대응하자는 일차적인 목표를 달성하는데는 몇 가지 방법이 있다.**        

1. 탄력성    
2. 복원력 


## 탄력성  
  
**탄력성이란?**    
* 다양한 작업 부하에서 응답성을 유지하는 능력을 의미한다.     
* 즉, 사용자 요청에 대한 응답 능력에 영향을 미칠 수 있는 모든 변화에 대응해야한다.   
         
작업이 많아지면 시스템 처리량이 자동으로 증가해야하고 작업이 감소하면 자동으로 감소해야한다.             
탄력성이 없는 시스템은 수요가 증가하면 평균 지연 시간이 증가하고, 시스템의 응답성에 직접적인 영향을 미친다.       
탄력성이 있는 시스템은 **평균 지연 시간에 영향을 미치지 않고 시스템을 확장할 수 있기에 시스템 응답성을 유지할 수 있다.**       
   
```     
지연 시간은 Reactive의 필수적인 특성이다   
탄력성이 없는 시스템에서는 수요가 증가하면 평균 지연 시간이 증가하고, 이것이 시스템의 응답성(Reactive)에 직접적인 영향을 미친다.  
```

`스케일 업`, `스케일 아웃`을 통해 시스템의 처리량을 증가시킬 수 있고 그 결과로 응답 능력을 향상시킬 수 있다.      
하지만, 역으로 시스템의 작업량이 낮은 경우에는 시스템을 축소하는 방향으로 비즈니스 비용을 절감하기도 해야한다.       
이렇듯 수평적 또는 수직적 확장(증대/감소)을 통해 우리가 목표하는 탄력성을 달성하고 유지할 수 있다.         
 
그러나 일반적으로 분산 시스템의 확장성을 달성하기 위해    
시스템 병목 지점 또는 동기화 지점을 확장하는 정도로 그치는게 일반적이다.    
 
이러한 문제는 암달의 법칙과 건터의 보편적 확장성 모델로 설명할 수 있으며   
이후, 배우게 될 웹플럭스-비동기 논블로킹에서 이문제를 다루고 해결하는 법에 대해서 공부할 것이다.    

      
## 복원력 

장애 발생과 상관없이 응답성(Reactive)에 대한 유지력을 갖추지 않은 채, 확장 가능한 분산시스템을 구축하는 것은 어려운 일이다.     
고품질 사용자 경험을 제공하기 위해서는 시스템의 응답성에 관심을 기울여야 한다.           
시스템에 대한 허용 기준은 시스템 실패에도 반응성을 유지할 수 있는 능력, 즉 시스템 복원력을 유지하는 것이다.      
**복원력은 시스템의 기능 요소를 격리해 모든 내부 장애를 격리하고 독립성을 확보함으로써 달성할 수 있다.(장애 전파X)**       
     
예시로, 결제 서비스가 중단되더라도 사용자 주문을 접수하고 이후에 자동으로 재시도함으로써 사용자를 원치 않는 장애로부터 보호할 수 있다.     
다른 예시로, 댓글 서비스에 장애가 발생하더라도 장바구니 확인이나 결제 서비스는 아무런 영향없이 정상적으로 동작해야한다.   

## 탄력성과 복원력 그리고 확장성 
 
탄력성과 복원력은 서로 밀접하게 결합되어있다.       
이 2가지를 모두 만족할 때, 시스템은 진정한 응답성(Reactive)를 가질 수 있다.       
그리고 이 2가지를 만족한 애플리케이션은 추가적으로 확장성을 도입해볼 수도 있다.     
   
확장성을 통해 다수의 복제본을 가지는 애플리케이션으로 구성할 수 있고     
이를 통해, 장애가 발생하더라도 시스템의 나머지 부분에 미치는 영향을 최소화하면서 복제본으로 전환할 수 있다.   

# 메시지 기반 통신 

* 컴포넌트를 연결하는 방법
* 낮은 결합도, 시스템 결합 및 확장성 유지 

분산 시스템에서 위와 같은 작업들을 동시에 달성할 수 있는지는 불분명하다.        
이를 증명하기 위해 HTTP를 이용해 컴포넌트 간의 통신을 수행하는 상황을 검토해보겠다.    

## 예시 

```java
@RequestMapping("/resource")  
public Object processRequest() {
    RestTemplate template = new RestTemplate();
    
    ExamplesCollection result = template.getForObject(
        "http://example.com/api/resource2",
        ExamplesCollection.class
    );
    ...
    processResultFurther(result);
}
```

사용자의 요청으로 호출되는 리퀘스트 핸들러를 정의해보았다.     
핸들러는 호출이 일어날 때마다 외부 서비스에 대한 추가 HTTP 요청을 발생시키고 차례로 다음 단계를 실행시킨다.   
이 코드는 논리적으로 투명해보이지만 몇 가지 문제가 있다.   

[#](#)  

타임라인에서 알 수 있듯이, 리퀘스트를 보내고 응답이 올때 까지 블록킹 대기상태가 되는 것을 알 수 있다.   
즉, 처리 시간의 일부만 효과적인 CPU 사용을 위해 할당되고 나머지는 스레드 A는 I/O에 의해 차단되며 다른 요청을 처리할 수 없다.        
            
이러한 문제를 해결하기 위한 방법 중 하나로    
자바에는 '스레드 풀'을 이용해 추가 스레드를 할당하여 병렬처리를 할 수 있다.         
하지만, 부하가 높은 상태에서는 이러한 기법 또한 새로운 I/O 작업을 동시에 처리하는데에는 매우 비효율적이다.    
(스레드를 많이 만들면 그만큼 동시성 문제를 해결하고 그 과정에서의 지연 시간도 길어질 수 있다.)    
이 같은 문제는 웹플럭스-비동기 논블로킹 통신에서 다시 한번 다루어보자   
      
**그렇다면 어떻게 해결할 수 있을까🤔**     
간단하게도, 비동기 논 블로킹 모델을 사용해에서 I/O 측면에서 리소스 활용도를 높이는 방법이 있다.      
현실에서 메시지를 보내고 할일 하다가 다시 메시지를 받고 보내는 방식이 업무 최적화에 남은 시간을 효율적으로 활용할 수 있게 해준다.       

[#](#) 

일반적으로 **`분산 시스템`에서 서비스 간에 통신을 할 때 자원을 효율적으로 사용하기 위해서는 `메시지 기반 통신 원칙`을 따랴야 한다.**           
즉, 비동기 논블로킹 방식으로 메시지를 보낼 수 있어야하며 또한 이러한 접근 방식은 **위치 투명성을 활성화해 시스템 확장성을 향상시킨다.**    
메시지 기반 통신을 수행하는 방법 중 하나는 **메시지 브로커**를 이용하는 것이다.          
  
**메시지 브로커의 장점**     
* 메시지 대기열(큐)을 모니터링해서 시스템이 부하를 관리할 수 있고 장애 대응을 할 수도 있다.     
* 명확한 흐름제어를 제공하고 전체 설계를 단순화싴니다.    

[#](#) 

지금까지 기술한 내용을 종합하면 위와 같은 리액티브 시스템의 기본 원리를 알 수 있다.    
      
그림에서 알 수 있듯이, **분산 시스템으로 구현되는 모든 비즈니스의 핵심 가치는 응답성이다.**              
시스템이 높은 응답성을 확보했다는 것은 **탄력성 및 복원력 같은 기본 기법도 이미 뒤따른다는 의미이다.**            
그리고 **응답성, 탄력성 및 복원력을 모두 확보하는 방법 중 하나로 메시지 기반 통신이 있다.**      
이러한 원칙을 제대로 구축한 시스템은 모든 구성요소가 독립적이고 적절하게 격리돼 있기 때문에 유지 보수 및 확장이 용이하다.       
(이 같은 개념은 리액티브 선언문(리액티브 시스템의 개념을 설명하는 용어집)에 정의되어있다.)      
    
**리액티브 선언문**   
리액티브 선언문은 기업과 개발들이 기존 개념을 동일하게 이해하도록 만들어진 선언문이다.      
리액티브 시스템과 리액티브 선언문은 아키텍처와 관련이 있으며,        
이는 대규모 분산 애플리케이션은 물론이고 소규모 단일 노드 애플리케이션에서도 적용할 수 있다.    

# 반응성에 대한 유스케이스 

리액티브 시스템은 아키텍처에 관한 것이며, 어디에나 적용될 수 있다.     
이번 단락에서는 리액티브 시스템을 만드는 데 도움이 되는 설계 개선 및 변경점에 대해서 알아본다.   

[#](#)  

위 아키텍처는 리액티브 시스템을 활용할 수 있는 유용한 사례중 하나이다.(모던 마이크로서비스 패턴 적용)      
위치 투명성을 달성하기 위해 [API 게이트웨이 패턴](https://docs.microsoft.com/ko-kr/dotnet/architecture/microservices/architect-microservice-container-applications/direct-client-to-microservice-communication-versus-the-api-gateway-pattern)을 사용했다.  
   
노드간의 강결합이 이루어지지 않았으므로, 서비스 노드를 스케일 아웃하여 가용성을 높일 수 있고     
요청을 처리하는 서비스에 대한 지식이 없어도 해당 리소스를 식별할 수 있게 해준다.       
  
```  
단, 클라이언트가 최소한 자원 이름은 알아야한다.     
API 게이트웨이가 요청 URI의 일부로 서비스 이름을 제공받으면 레지스트리 서비스에 요청해 특정 서비스 주소를 확인하기 때문이다.   
```
  
또한, 각 서비스의 가용성 정보를 최신으로 유지하는 책임은(어느 서비스를 사용할 것인지)     
'서비스 레지스트리 패턴'으로 구현하고 클라이언트 측 '디스커버리 패턴'을 통해 달성한다.     
위 그림에서는 서비스 게이트웨이와 서비스 레지스트리가 동일한 시스템에 설치되어 있기 때문에 소규모 시스템의 경우 유용할 수 있다.  
    
장애 복원력은 여러 방면에서 이루어지고 있다.   
아파치 카프카를 이용해 '적절하게 구성한 메시지 기반 통신'과 '독립적인 결제 서비스'에 의해 이루어진다.(재시도 가능)       
데이터베이스는 Replication 을 통해 하나가 중단되더라도 복원할 수 있는 복원력을 유지했다.       
 
응답성을 유지하기 위해       
주문 요청을 받자마자 우선 응답을 보낸후, 이를 비동기적으로 처리해 사용자 결제 요청을 결제 서비스로 보낸다.      
최종 결과 안내는 지원하는 채널(이메일)에 의해 나중에 전달된다.    



  








