# 왜 리액티브인가?  
  
서비스 애플리케이션에서 가장 중요하게 생각할 문제는 **어떻게 대응할 것인가?** 이다.       
쉽게 말하자면, 서비스 애플리케이션은 부하의 변화 및 외부 서비스의 가용성 변화에 대응을 해야한다.         
즉, **사용자 요청에 대한 응답 능력에 영향을 미칠 수 있는 모든 변화에 대응해야한다.(Reactive)**    
    
**변화에 대응하자는 일차적인 목표를 달성하는데는 몇 가지 방법이 있다.**        

1. 탄력성    
2. 복원력 

## 탄력성  
  
**탄력성이란?**    
* 다양한 작업 부하에서 응답성을 유지하는 능력을 의미한다.     
* 즉, 사용자 요청에 대한 응답 능력에 영향을 미칠 수 있는 모든 변화에 대응해야한다.   
         
작업이 많아지면 시스템 처리량이 자동으로 증가해야하고 작업이 감소하면 자동으로 감소해야한다.             
탄력성이 없는 시스템은 수요가 증가하면 평균 지연 시간이 증가하고, 시스템의 응답성에 직접적인 영향을 미친다.       
탄력성이 있는 시스템은 **평균 지연 시간에 영향을 미치지 않고 시스템을 확장할 수 있기에 시스템 응답성을 유지할 수 있다.**       
   
```     
지연 시간은 Reactive의 필수적인 특성이다   
탄력성이 없는 시스템에서는 수요가 증가하면 평균 지연 시간이 증가하고, 이것이 시스템의 응답성(Reactive)에 직접적인 영향을 미친다.  
```

`스케일 업`, `스케일 아웃`을 통해 시스템의 처리량을 증가시킬 수 있고 그 결과로 응답 능력을 향상시킬 수 있다.      
하지만, 역으로 시스템의 작업량이 낮은 경우에는 시스템을 축소하는 방향으로 비즈니스 비용을 절감하기도 해야한다.       
이렇듯 수평적 또는 수직적 확장(증대/감소)을 통해 우리가 목표하는 탄력성을 달성하고 유지할 수 있다.         
 
그러나 일반적으로 분산 시스템의 확장성을 달성하기 위해    
시스템 병목 지점 또는 동기화 지점을 확장하는 정도로 그치는게 일반적이다.    
 
이러한 문제는 암달의 법칙과 건터의 보편적 확장성 모델로 설명할 수 있으며   
이후, 배우게 될 웹플럭스-비동기 논블로킹에서 이문제를 다루고 해결하는 법에 대해서 공부할 것이다.    

      
## 복원력 

장애 발생과 상관없이 응답성(Reactive)에 대한 유지력을 갖추지 않은 채, 확장 가능한 분산시스템을 구축하는 것은 어려운 일이다.     
고품질 사용자 경험을 제공하기 위해서는 시스템의 응답성에 관심을 기울여야 한다.           
시스템에 대한 허용 기준은 시스템 실패에도 반응성을 유지할 수 있는 능력, 즉 시스템 복원력을 유지하는 것이다.      
**복원력은 시스템의 기능 요소를 격리해 모든 내부 장애를 격리하고 독립성을 확보함으로써 달성할 수 있다.(장애 전파X)**       
     
예시로, 결제 서비스가 중단되더라도 사용자 주문을 접수하고 이후에 자동으로 재시도함으로써 사용자를 원치 않는 장애로부터 보호할 수 있다.     
다른 예시로, 댓글 서비스에 장애가 발생하더라도 장바구니 확인이나 결제 서비스는 아무런 영향없이 정상적으로 동작해야한다.   

## 탄력성과 복원력 그리고 확장성 
 
탄력성과 복원력은 서로 밀접하게 결합되어있다.       
이 2가지를 모두 만족할 때, 시스템은 진정한 응답성(Reactive)를 가질 수 있다.       
그리고 이 2가지를 만족한 애플리케이션은 추가적으로 확장성을 도입해볼 수도 있다.     
   
확장성을 통해 다수의 복제본을 가지는 애플리케이션으로 구성할 수 있고     
이를 통해, 장애가 발생하더라도 시스템의 나머지 부분에 미치는 영향을 최소화하면서 복제본으로 전환할 수 있다.   

# 메시지 기반 통신 

* 컴포넌트를 연결하는 방법
* 낮은 결합도, 시스템 결합 및 확장성 유지 

분산 시스템에서 위와 같은 작업들을 동시에 달성할 수 있는지는 불분명하다.        
이를 증명하기 위해 HTTP를 이용해 컴포넌트 간의 통신을 수행하는 상황을 검토해보겠다.    

## 예시 

```java
@RequestMapping("/resource")  
public Object processRequest() {
    RestTemplate template = new RestTemplate();
    
    ExamplesCollection result = template.getForObject(
        "http://example.com/api/resource2",
        ExamplesCollection.class
    );
    ...
    processResultFurther(result);
}
```

사용자의 요청으로 호출되는 리퀘스트 핸들러를 정의해보았다.     
핸들러는 호출이 일어날 때마다 외부 서비스에 대한 추가 HTTP 요청을 발생시키고 차례로 다음 단계를 실행시킨다.   
이 코드는 논리적으로 투명해보이지만 몇 가지 문제가 있다.   

[#](#)  

타임라인에서 알 수 있듯이, 리퀘스트를 보내고 응답이 올때 까지 블록킹 대기상태가 되는 것을 알 수 있다.   
즉, 처리 시간의 일부만 효과적인 CPU 사용을 위해 할당되고 나머지는 스레드 A는 I/O에 의해 차단되며 다른 요청을 처리할 수 없다.        
            
이러한 문제를 해결하기 위한 방법 중 하나로    
자바에는 '스레드 풀'을 이용해 추가 스레드를 할당하여 병렬처리를 할 수 있다.         
하지만, 부하가 높은 상태에서는 이러한 기법 또한 새로운 I/O 작업을 동시에 처리하는데에는 매우 비효율적이다.    
(스레드를 많이 만들면 그만큼 동시성 문제를 해결하고 그 과정에서의 지연 시간도 길어질 수 있다.)    
이 같은 문제는 웹플럭스-비동기 논블로킹 통신에서 다시 한번 다루어보자   
      
**그렇다면 어떻게 해결할 수 있을까🤔**     
간단하게도, 비동기 논 블로킹 모델을 사용해에서 I/O 측면에서 리소스 활용도를 높이는 방법이 있다.      
현실에서 메시지를 보내고 할일 하다가 다시 메시지를 받고 보내는 방식이 업무 최적화에 남은 시간을 효율적으로 활용할 수 있게 해준다.       

[#](#) 

일반적으로 **`분산 시스템`에서 서비스 간에 통신을 할 때 자원을 효율적으로 사용하기 위해서는 `메시지 기반 통신 원칙`을 따랴야 한다.**           
즉, 비동기 논블로킹 방식으로 메시지를 보낼 수 있어야하며 또한 이러한 접근 방식은 **위치 투명성을 활성화해 시스템 확장성을 향상시킨다.**    
메시지 기반 통신을 수행하는 방법 중 하나는 **메시지 브로커**를 이용하는 것이다.          
  
**메시지 브로커의 장점**     
* 메시지 대기열(큐)을 모니터링해서 시스템이 부하를 관리할 수 있고 장애 대응을 할 수도 있다.     
* 명확한 흐름제어를 제공하고 전체 설계를 단순화싴니다.    

[#](#) 

지금까지 기술한 내용을 종합하면 위와 같은 리액티브 시스템의 기본 원리를 알 수 있다.    
      
그림에서 알 수 있듯이, **분산 시스템으로 구현되는 모든 비즈니스의 핵심 가치는 응답성이다.**              
시스템이 높은 응답성을 확보했다는 것은 **탄력성 및 복원력 같은 기본 기법도 이미 뒤따른다는 의미이다.**            
그리고 **응답성, 탄력성 및 복원력을 모두 확보하는 방법 중 하나로 메시지 기반 통신이 있다.**      
이러한 원칙을 제대로 구축한 시스템은 모든 구성요소가 독립적이고 적절하게 격리돼 있기 때문에 유지 보수 및 확장이 용이하다.       
(이 같은 개념은 리액티브 선언문(리액티브 시스템의 개념을 설명하는 용어집)에 정의되어있다.)      
    
**리액티브 선언문**   
리액티브 선언문은 기업과 개발들이 기존 개념을 동일하게 이해하도록 만들어진 선언문이다.      
리액티브 시스템과 리액티브 선언문은 아키텍처와 관련이 있으며,        
이는 대규모 분산 애플리케이션은 물론이고 소규모 단일 노드 애플리케이션에서도 적용할 수 있다.    

# 반응성에 대한 유스케이스 

리액티브 시스템은 아키텍처에 관한 것이며, 어디에나 적용될 수 있다.     
이번 단락에서는 리액티브 시스템을 만드는 데 도움이 되는 설계 개선 및 변경점에 대해서 알아본다.   

## 소형 웹 스토어(마이크로 서비스 아키텍처)

[#](#)  

위 아키텍처는 리액티브 시스템을 활용할 수 있는 유용한 사례중 하나이다.(모던 마이크로서비스 패턴 적용)      
위치 투명성을 달성하기 위해 [API 게이트웨이 패턴](https://docs.microsoft.com/ko-kr/dotnet/architecture/microservices/architect-microservice-container-applications/direct-client-to-microservice-communication-versus-the-api-gateway-pattern)을 사용했다.  
   
노드간의 강결합이 이루어지지 않았으므로, 서비스 노드를 스케일 아웃하여 가용성을 높일 수 있고     
요청을 처리하는 서비스에 대한 지식이 없어도 해당 리소스를 식별할 수 있게 해준다.       
  
```  
단, 클라이언트가 최소한 자원 이름은 알아야한다.     
API 게이트웨이가 요청 URI의 일부로 서비스 이름을 제공받으면 레지스트리 서비스에 요청해 특정 서비스 주소를 확인하기 때문이다.   
```
  
또한, 각 서비스의 가용성 정보를 최신으로 유지하는 책임은(어느 서비스를 사용할 것인지)     
'서비스 레지스트리 패턴'으로 구현하고 클라이언트 측 '디스커버리 패턴'을 통해 달성한다.     
위 그림에서는 서비스 게이트웨이와 서비스 레지스트리가 동일한 시스템에 설치되어 있기 때문에 소규모 시스템의 경우 유용할 수 있다.  
    
**장애 복원력**    
아파치 카프카를 이용해 '적절하게 구성한 메시지 기반 통신'과 '독립적인 결제 서비스'에 의해 이루어진다.(재시도 가능)       
데이터베이스는 Replication 을 통해 하나가 중단되더라도 복원할 수 있는 복원력을 유지했다.       
   
**응답성**          
주문 요청을 받자마자 우선 응답을 보낸후, 이를 비동기적으로 처리해 사용자 결제 요청을 결제 서비스로 보낸다.       
최종 결과 안내는 지원하는 채널(이메일)에 의해 나중에 전달된다.      

## 애널리틱스 분야(스트리밍 아키텍처)  
  
리액티브 시스템 접근법이 적절한 또 다른 복잡한 영역 중 하나로 애널리틱스 분야가 있다.        
애널리틱스는 엄청난 양의 데이터를 다루면서 런타임에 처리하고     
사용자에게 실시간으로 통계를 제공함으로써 항상 최신의 정보를 유지하는 기능을 제공한다.    

엄청난 데이터를 처리하고 통신 네트워크 상태, 품질 및 트래픽에 대한 실시간 모니터링을 제공하는 것은 어렵다.  
이 시스템을 설계하기 위해 **스트리밍**이라는 효율적인 아키텍처를 사용할 수 있다.   

[#](#)  

스트리밍 아키텍처는 데이터 처리 및 변환 흐름을 만드는 것이다.         
일반적으로 이러한 시스템은 짧은 지연 시간과 높은 처리량이 특징이다.      
따라서 **통신 네트워크 상태에 대한 분석된 업데이트에 응답하거나 전달하는 능력이 매우 중요하다.**     

이러한 가용성이 높은 시스템을 구축하려면 리액티브 선언문에서 언급한 기본 원칙에 의존해야한다.    
복원성을 확보하기 위해 배압 지원(장애 전파 방지)을 활성화해야한다.     

메시지 브로커를 통한 메시지 기반 통신을 사용해 작업 부하 관리를 효울적으로 수행할 수 있다.       
이 통신 방식은 메시지를 내부 저장소에 보관하고 요청이 있을 때 전송할 수 있다.    

또한 시스템의 각 구성 요소를 적절하게 변경해 시스템 처리량을 탄력적으로 확장하거나 줄일 수 있다.   
      
실제 환경에서는 데이터 스트림이 일괄 처리로 데이터베이스에 저장되거나         
윈도우잉(windowing) 또는 머신러닝을 적용해 거의 실시간에 가깝게 처리될 수도 있다.         
하지만, 리액티브 선언문이 제공하는 모든 기본 원칙은 전체 도메인 또는 비즈니스 아이디어와 관계없이 유효하다.      
     
리액티브 시스템 구축의 기본 원리를 적용한 영역은 다양하게 존재한다.(여러 아키텍처들)     
사용자에게 효과적이고 인터랙티브한 피드백을 제공하는 거의 모든 종류의 분산 시스템 구축에 리액티브 원리를 적용할 수 있기 때문에,  
리액티브 시스템의 적용 영역은 예시로 제공한 영역으로 제한되지는 않는다.     
  
# 왜 리액티브 스프링인가?     
> 스프링 프레임워크를 리액티브로 전환하는 이유   

리액티브 접근법을 통해, 탄략성과 복원력과 같은 기본 요소의 사용을 확대하고     
리액티브 시스템을 위해 일반적으로 사용되는 마이크로서비스의 예를 살펴보았다.   
 
리액티브 시스템의 복잡성을 강조하는 것은 중요하며 이를 위해 아키텍처 관점에서 살펴보았다.  
그리고 이러한 시스템을 구축하는 것은 매우 어려운 것 또한 알게 되었다.       

리액티브 시스템을 쉽게 구축하려면 먼저 여러 프레임워크를 분석한 다음 그 중 하나를 선택하면 된다.    
프레임워크를 선택하는 가장 일반적인 방법의 하나는 각 프레임워크의 기능, 연관성 및 커뮤니티를 분석하는 것이다.    
JVM 세계에서 리액티브 시스템을 구축하는데 가장 널리 알려진 프레임워크는 Akka, Vert.x 이다.  
(Akka 와 Vert.x 에대한 설명은 생략하겠다.)   

스프링 프레임워크는 개발자에게 친숙한 프로그래밍 모델을 사용해 웹 애플리케이션을 구축할 수 있는 다양한 방법을 제공한다.  
하지만 견고한 리액티브 시스템을 구축하는데 몇가지 제약이 있어서 제대로 도입하지 못하고 있었다.(지금은 제공한다.)  

## 서비스 레벨에서의 반응성 

스프링 진영에서, 리액티브 시스템에 대한 수요 증가로 **스프링 클라우드**라는 새로운 스프링 프로젝트가 개발되었다.   
스프링 클라우드 프레임워크는 분산 시스템 구축을 단순화하는 프로젝트이다.       
결과적으로 스프링 프레임워크 생태계는 리액티브 시스템을 구축하는데 적합하게 변했다.     
(최소한의 노력으로 견고한 리액티브 마이크로서비스 시스템을 구축하는 솔루션이 등장한 것이다.)   

```  
큰 시스템은 더 작은 규모의 시스템으로 구성되기 때문에 구성 요소의 리액티브 특성에 의존한다.     
즉, 리액티브 시스템은 설계 원칙을 적용하고, 이 특성을 모든 규모에 적용해 그 구성 요소를 합성할 수 있게 하는 것을 의미한다.  
``` 
  
리액트 선언문에서 주지하다시피, 전체 시스템 설계는 리액티브 시스템을 구축하는 데 있어 하나의 요소일 뿐이다.      
따라서 구성 요소 수준에서도 리액티브 설계 및 구현을 제공하는 것이 중요하다.    
이러한 맥락에서, **설계 원칙이란 컴포넌트 사이의 관계를 말한다.(기본 요소를 조합하는 데 사용하는 프로그래밍 기법)**       
자바에서 코드를 작성하는 가장 보편적인 기법은 **명령형 프로그래밍**이다.     

[#](#) 

이 그림에는 웹 스토어 애플리케이션을 구성하는 2개의 컴포넌트가 있다.      
이 경우 OrdersService는 사용자 요청을 처리하기 위해 ShoppingCardServie를 호출한다.        
    
내부에 있는 ShoppingCardService 가 HTTP 요청이나 데이터베이스 쿼리와 같이 시간이 걸리는 I/O 작업을 실행한다고 가정한다.    
명령형 프로그래밍의 단점을 이해하기 위해 앞서 언급한 컴포넌트 간의 상호 작용에 대한 가장 일반적인 구현 예시를 보자   

```java
interface ShoppingCardService {
    Output calculate(Input value);
}

class OrderService {
    private final ShoppingCardService scService;
    
    void process() {
        Input input = ...
        Output output = scService.calculate(input);
        ...
    }
}
```

이 서비스는 시간과 강결합되거나 단순히 OrderServie를 실행하는 경우에도 ShoppingCardService의 실행 결과와 강결합된다.       
**안타깝게도 이러한 기술을 사용하면 ShoppingCardService 가 요청을 처리하는 동안 다른 직업을 실행할 수 없다.**           
  
`scService.calculate(input);`를 처리하는 동안 스레드가 차단된다.            
따라서 OrderService에서 별도의 독립적인 처리를 실행하려면 추가 스레드를 할당해야한다.      

하지만, **추가 스레드를 할당하는 것은 낭비일 수 있고, 리액티브 시스템의 관점으로 본다면 그런 식의 동작은 허용하지 않는다.**          
    
```java
interface ShoppingCardService {
    void calculate(Input value, Consumber<Output> c);
}

class OrderService {
    private final ShoppingCardService scService;
    
    void process() {
        Input input = ...;
        scService.calculate(input, output -> { ... });    
    }
}
```
`ShoppingCardService`는 설계 관점에서 호출하는 인스턴스가 즉시 대기 상태에서 해제될 수 있으며, 결과는 `Consumer<>` 콜백으로 전달된다.  

OrderService `process()`는 비동기식으로 `ShopCardService의 calculate()`를 호출하고 작업을 진행한다.         
ShopCardService가 콜백 함수를 실행하면 실제 결과에 대한 처리를 계속할 수 있다.       
   
`ShopCardService의 calculate()`는 작업 완료 후에 반응할 콜백 함수(2번째 파라미터)를 전달한다.                 
**이것은 OrderService 가 ShoppingCardService 로 부터 분리 됐음을 의미한다.**                
        
아울러 OrderService 로 결과를 전달하는 함수형 콜백 호출를 통해       
동기 또는 비동기적인 방식으로 `ShoppingCardService.calculate()`를 구현할 수 있다.      

```java
class SyncShoppingCardService implements ShoppingCardService {
    public void calculate(Input value, Consumer<Output> c) {
        Output result = new Output();
        c.accept(result);
    }
}
```
* 이 구현은 블로킹이 없다고 가정한다.            
* 여기서는 I/O 실행을 하지 않기 때문에 결과를 콜백 함수에 전달해 즉시 반환할 수 있다.    
  
```java
class AsyncShoppingCardService implements ShoppingCardService {
    public void calculate(Input value, Consumer<Output> c) {
        new Thread(() -> {
            Output result = template.getForObject(...);
            ...
            c.accept(result);
        }).start();
    }
}
```    
* I/O를 차단할 때 별도의 Thread 로 래핑할 수 있다.     
* 결과를 받으면 콜백함수를 호출해 결과를 전달한다.        
     
OrderService는 실행 프로세스와 분리돼 콜백으로 결과를 받을 수 있다.      
이러한 방식의 장점은 컴포넌트가 콜백 함수에 의해 분리된다는 점이다.      
즉, scService.calculate 메서드를 호출한 후      
ShoppingCardService 의 응답을 기다리지 않고 즉시 다른 작업을 진행할 수 있다.  
    
단점이라면 공유 데이터 변경 및 콜백 지옥을 피하기 위해 개발자가 멀티 스레딩을 잘 이해하고 있어야한다.   
  
다행스럽게도, 콜백만이 유일한 옵션은 아니며 또 하나의 대안은 Future 클래스를 사용하는 것이다.      
Future 클래스는 실행 동작을 어느 정도 숨기고 구성 요소도 분리한다.     

```java
interface ShoppingCardService {
    Future<Ouput> calculate(Input value);
}

class OrderService {
    private final ShoppingCardService scService;
    void process() {
        Input input = ...;
        Future<Output> future = scService.calculate(input);
        ...
        Output output = future.get();
        ...
    }
}
```
`calculate()` 메서드는 하나의 인자를 받고 Future 클래스를 반환한다.      
Futur 클래스는 래퍼를 사용해 사용 가능한 결과가 있는지를 확인한다.     
   
`process()` 메서드는 비동기적으로 calculate()를 호출하고 Future 인스턴스를 반환받는다.          
결과가 비동기적으로 처리되는 동안 다른 처리를 계속할 수 있다.        
즉, ShoppingCardService#calculate와는 독립적으로 수행될 수 있는 몇번의 실행 후에 결과를 얻는다.       
이 결과는 블로킹 방식으로 결과를 기다리거나 즉시 결과를 반환할 수 있다.(메서드에 따라 방식 달라짐)       
     
Future 클래스 사용으로 결괏값 반환을 지연시킬 수 있다.             
Future 클래스를 통해 콜백 지옥을 피할 수 있고, Future 구현 뒤에 멀티 쓰레드의 복잡성을 숨길 수 있다.          
**어쨌든 필요한 결과를 얻으려면 현재 스레드를 차단하고 확장성을 현저히 저하시키는 외부 실행과 동기화해야한다.**        

자바8에서는 이를 개선해 CompletionStage를 직접 구현한 CompletableFuture를 제공한다.       
이 클래스를 이용하면, JS의 promise와 유사한 API를 제공해준다.      

### CompletionStage

```java
interface ShoppingCardService {
    CompletionStage<Output> calculate(Input value);
}

class OrderService {
    private final ShoppingCardService scService;
    void process() {
        Input input = ...;
        scService.calculate(input)
            .thenApply(out1 -> { ... })
            .thenCombine(out2 -> { ... })
            .thenAccept(out3 -> { ... });
    }
}
```
CompletionStage는 Future와 비슷한 래퍼클래스이지만, 반환된 결과를 기능적 선언 방식으로 처리할 수 있다.   
    
`process()`는 calculate()를 비동기적으로 호출하고 실행 결과로 CompletionStage 를 즉시 반환받는다.     
CompletionStage는 thenAccept 및 thenCombine과 같은 메서드를 제공해준다.     
결과에 대한 변형 연산을 정의하거나 결과를 처리하는 최종 컨슈머를 정의할 수 있는 thenAccept 메서드를 정의할 수 있다.  
  
CompletionStage의 지원으로 함수형 스타일 또는, 선언현 스타일로 코드를 작성할 수 있다.      
코드는 깔끔해지고 비동기적으로 처리를 한다.      
또한, 결과를 기다리지 않고 결과가 나오면 이를 처리할 함수를 제공할 수 있다.         
게다가 예제에서 표현된 기법은 모두 스프링팀이 검토했으며, 프레임워크내의 대부분 프로젝트에서 이미 구현되어있다.   

CompletionStage 가 효율적이고 읽기 쉬운 코드를 작성하는 데 더 나은 가능성을 제공하지만, 안타깝게도 몇가지 부족한 점이 있다.       
Spring4에서는 구형 자바 버전과 호환하기 위해서 CompletionStage 대신, ListenableFuture를 사용했다.    

### ListenableFuture 
  
ListenableFuture를 이해하기 위해서는 AsyncRestTemplate 사용법을 살펴봐야한다.     

```java
AsyncRestTemplate template = new AsyncRestTemplate();
SucessCallback onSucess = r -> { ... };
FailureCallBack onFailure = e -> { ... };
ListenableFuture<?> response = template.getForEntity(
    "http://example.com/api/examples",
    ExamplesCollection.class
);
response.addCallBack(onSucess, onFailure);
```
위 코드는 비동기 호출을 처리하기 위한 콜백 스타일을 보여준다.      
본질적으로 이 방법은 지저분하며, 스프링 프레임워크는 블로킹 네트워크 호출을 별도의 스레드로 래핑한다.        
또한, 스프링 MVC는 모든 구현체가 각각의 요청에 별도의 스레드를 할당하는 서블릿 API를 사용한다.    

```
스프링 프레임워크5와 새로운 리액티브 웹 클라이언트가 출시되면서 많은 부분이 변경됐으며     
WebClient의 도입을 통해 모든 서비스간 통신에 논블로킹 통신을 지원한다.    
  
또한, 서블릿 3.0은 비동기적인 클라이언트-서버 통신을 도입했는데, 서블릿 3.1은 논블로킹 I/O 쓰기를 허용한다.       
서블릿 3 API에 포함된 대부분 비동기 논블로킹 기능은 스프링 MVC에 잘 통합되어 있다.     
  
그러나 한가지 문제는 스프링 MVC가 비동기 논블로킹 클라이언트를 제공하지 않음으로써      
개선된 서블릿 API의 모든 이점을 무효로 만들었다는 것이다.  
```

이 모델은 상당히 비효율적이다.    
이 모델이 비효율적인 이유를 이해하려면 멀티 스레딩 비용을 다시 고려해야한다.    
멀티 스레딩은 본질적으로 복잡한 기술이다.   
멀티 스레딩을 할 때는 여러 스레드에서 공유 메모리에 액세스, 동기화, 오류 처리 등과 같은 많은 작업을 생각해야한다.    
    
자바에 있는 멀티 스레딩 디자인은 몇몇 스레드가 그들의 작업을 동시에 실행하기 위해 하나의 CPU를 공유할 수 있다고 가정했다.      
CPU 시간이 여러 스레드간에 공유된다는 사실은 컨텍스트 스위칭이라는 개념을 끌어들인다.     
즉, 나중에 스레드를 다시 시작하려면 레지스터, 메모리 맵 및 기타 관련 요소를 저장하고 불러와야 한다.     
결과적으로 적은 수의 CPU 에 동시에 많은 수의 스레드를 활성화시키는 응용 프로그램은 비효율적이다.  
    
일반적인 자바 스레드는 메모리 소비에 오버헤드가 있다.       
64비트 JVM에서 스레드의 일반적인 스택 크기는 1,024KB이다.           
한편, 커넥션마다 별도의 스레드를 할당하는 모델에서 6,4000 개의 동시 요청을 처리하려는 시도는 약 64GB 메모리를 필요로 한다.        
이는 비즈니스 관점에서 볼 때 비용이 많이 들고 애플리케이션 관점에서 위험한 일일 수 있습니다.    
 
제한된 크기 스레드 풀을 제공하는 기존 모델로 전환하고 요청에 대해 미리 구성된 대기열을 사용하면,      
클라이언트가 응답을 받기까지의 대기 시간이 길어지고 평균 응답 시간이 길어지면서 결국 응용프로그램이 응답하지 않을 수 있다.   

이를 위해 리액티브 선언문은 논블로킹 작업을 사용하도록 권장했으나, 과거 스프링 생태계에서는 누락돼있었다.     
또한 컨텍스트 스위칭 문제를 해결한 네티와 같은 리액티브 서버와는 제대로 된 통합을 지원하지 않았다.       
  
비동기 처리는 일반적인 요청-응답 패턴에만 국한되지 않는다.     
때로는 데이터의 연속적인 스트림으로 처리해야할 수도 있고, 배압 지원이 있는 정렬된 변환 흐름으로 처리해야하는 경우도 있다.   

[#](#) 

리액티브 프로그래밍으로 이런 사례를 처리하는 방법 중 하나는 비동기 이벤트 처리 내부에 변형 단계 연결을 포함하는 것이다.     
결과적으로, 리액티브 프로그래밍은 리액티브 시스템의 설계 요구 사항에 적합한 좋은 기술이다.        
다음 장에서는 리액티브 시스템을 구축하기 위한 리액티브 프로그래밍 적용의 가치에 대해 다룬다.    

[#](#) 

안타깝게도 리액티브 프로그래밍 기술은 스프링 프레임워크 안에 잘 통합돼어 있지 않았었다.    
이로인해 모던 응용 프로그램을 구축하는 데 한계가 있었으며, 프레임워크의 경쟁력이 떨어져다.    
결과적으로 리액티브 시스템 및 리액티브 프로그래밍에 대한 과장된 글에 언급된 격차들은 프레임워크의 비약적인 개선의 필요성을 증가시켰다.   
마지막으로 모든 레벨에서 반응성에 대한 지원을 추가하고, 개발자에게 리액티브 시스템 개발을 위한 강력한 도구를 제공함으로써   
스프링 프레임워크의 개선을 크게 자극했다.  

핵심 개발자들은 리액티브 시스템의 기반으로서 스프링 프레임워크의 역량을 보여주는 새로운 모듈을 구현하기로 했다.  

# 요약 

최근에 자주 언급되는 IT 솔루션의 비용 효율성에 대한 요구사항을 살펴보았다.   
아마존과 같은 대기업이 구식 아키택처 패턴 위에서 최신 클라우드 기반 분산 시스템을 원할하게 구동하지 못하는 이유를 알아봤다.  

또한 편리하고 효율적이며 지능적인 디지털 서비스에 대한 수요 증가에 대응하기 위해    
새로운 아키텍처 패턴과 프로그래밍 기법이 필요하다는 것을 확인했다.     
리액티브 선언문을 통해 반응성이라는 용어를 이해했다.    
디지털 시대의 주요 비기능적 시스템 요구 사항인 탄력성, 복원력 및 메시지 기반 접근 방식이     
응답성 확보에 도움이 되는 이유와 그 방법에 관해서도 설명했다.    
아울러 리액티브 시스템에 매우 적합하고 비즈니스 목표를 달성하게 해주는 예제를 학습했다.   

이 장에서는 아키텍처 패턴으로 리액티브 시스템과 프로그래밍 기술로서의 리액티브 프로그래밍의 명확한 차이점을 강조했다.   
2가지 유형의 반응성이 왜 잘 어울리는지, 어떻게 매우 효율적인 고 가용성 IT 솔루션을 만들 수 있는지 설명했다.   

리액티브 스프링5를 더 깊이 이해하려면 리액티브 프로그램 기초를 확실하게 이해해야하며,   
그 기술을 결정하는 기본 개념과 패턴을 배워야한다.   
    
빨리 공부하자...
