# 왜 리액티브인가?  
  
가장 중요하게 생각할 문제는 **어떻게 대응할 것인가?** 이다.         
애플리케이션은 수요(부하)의 변화 및 외부 서비스의 가용성 변화에 대응을 해야한다.     
즉, **사용자 요청에 대한 응답 능력에 영향을 미칠 수 있는 모든 변화에 대응해야한다.**   

일차적인 목표를 달성하는데 몇가지 방법이 있다. 
 
1. 탄력성 :   
    * 다양한 작업 부하에서 응답성을 유지하는 능력을 의미한다.    
    * 수요(작업)이 많아지면 시스템 처리량이 자동으로 증가해야하고 수요(작업)이 감소하면 자동으로 감소해야한다.    
    * 평균 지연 시간에 영향을 미치지 않고 시스템을 확장할 수 있기에 시스템 응답성을 유지할 수 있다.   
        * 지연 시간은 응답성의 필수적인 특성이다.
          탄력성이 없는 시스템에서는 수요가 증가하면 평균 지연 시간이 증가하고, 시스템의 응답성에 직접적인 영향을 미친다.    
    * 수평적 또는 수직적 **확장**을 통해 탄력성을 달성할 수 있다.    
    * 그러나 분산 시스템에의 확장성을 달성하기 위해 시스템 병목 지점 또는 동기화 지점을 확장하는 정도로 그치는게 일반적이다.  
    * 이러한 문제는 암달의 법칙과 건터의 보편적 확장성 모델로 설명할 수 있다.  
  
2. 복원력 : 
    * 장애 발생과 상관없이 **응답성을 유지하는 능력을 갖추지 않은 채로 확장 가능한 분산 시스템을 구축하는 것을 어려운 일이다.**   
    * 고품질 사용자 경험을 제공하기 위해서는 시스템의 응답성에 관심을 기울여야 한다.     
    * 시스템에 대한 허용 기준은 시스템 실패에도 반응성을 유지할 수 있는 능력, 즉 시스템 복원력을 유지하는 것이다.       
    * 이는 시스템의 기능 요소를 격리해 모든 내부 장애를 격리하고 독립성을 확보함으로써 달성할 수 있다.       
   
또 하나 강조할 점은 탄력성과 복원력이 밀접하게 결합돼 있으며          
이 2가지를 모두 사용할 때만 시스템의 진정한 응답성을 달성할 수 있다.         
확장성을 통해 다수의 복제본을 가질 수 있으므로 하나의 노드에 장애가 발생한 경우,        
이를 탐지하고 시스템의 나머지 부분에 미치는 영향을 최소화하며 다른 복제본으로 전환할 수 있다.    

## 메시지 기반 통신 

분산 시스템에서 컴포넌트를 연결하는 방법과     
낮은 결합도, 시스템 격리 및 확장성 유지를 어떻게 하면 동시에 달성할 수 있는지는 여전히 불분명하다.    

```java
```

[#](#)  

보다시피 처리 시간의 일부만 효과적인 CPU 사용을 위해 할당되고     
나머지 시간 동안 스레드 A는 I/O에 의해 차단되며 다른 요청을 처리할 수 없다.     
 
자바에는 병렬 처리를 위해 추가 스레드를 할당할 수 있는 스레드 풀이 있다.     
그러나 부하가 높은 상탱서는 이러한 기법이 새로운 I/O 작업을 동시에 처리하는데에는 매우 비효율적일 수 있다.    
  
I/O 측면에서 리소스 활용도를 높이려면 비동기 논 블로킹 모델을 사용해야 한다는 점에는 동의할 수 있다.       
현실에서 카톡처럼, 메시지를 보내고 할일을 하다가 다시 메시지를 보내는 방식이 업무 최적화에 남은 시간을 효율적으로 활용할 수 있게 해준다.     
  
일반적으로 분산 시스템에서 서비스 간에 통신할 때 자원을 효율적으로 사용하기 위해서는 메시지 기반 통신 원칙을 따랴야 한다.    
즉비동기 논블로킹 방식으로 메시지를 보낼 수 있어야하며 또한 이러한 접근 방식은 위치 투명성을 활성화해 시스템 확장성을 향상시킨다.   





